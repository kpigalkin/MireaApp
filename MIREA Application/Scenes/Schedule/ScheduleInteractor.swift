//
//  ScheduleInteractor.swift
//  MIREA Application
//
//  Created by Кирилл Пигалкин on 04.08.2022.
//  Copyright (c) 2022 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol ScheduleBusinessLogic {
    func getTeachersList(with request: ScheduleModels.Teachers.Request)
    func getDayClasses(with request: ScheduleModels.Classes.Request)
}

protocol ScheduleDataStore {
    var schedule: (classes: ScheduleModels.Classes.ResponseItems, stringId: String) { get set }
    var components: URLComponents { get set }
}

final class ScheduleInteractor: ScheduleBusinessLogic, ScheduleDataStore {
    var presenter: SchedulePresentationLogic?
    var schedule = (classes: ScheduleModels.Classes.ResponseItems(), stringId: "")
    var components: URLComponents = {
        var components = URLComponents()
        components.scheme = "https"
        components.host = "tt-mosit.mirea.ru"
        return components
    }()
    
    func getTeachersList(with request: ScheduleModels.Teachers.Request) {
        print("⭕️ getTeachersList in ScheduleInteractor")
        
        components.path = "/teachers"
        guard let url = components.url else { return }

        let task = URLSession.shared.dataTask(with: url) { data, response, error in
            if let data = data, let teachers = try? JSONDecoder().decode(ScheduleModels.Teachers.Response.self, from: data) {
                DispatchQueue.main.async {
                    self.presenter?.presentTeachersList(with: teachers)
                }
            }
        }
        task.resume()
    }

    func getDayClasses(with request: ScheduleModels.Classes.Request) {
        print("⭕️ getDayClasses in ScheduleInteractor")
        
        guard let value = UserDefaults.standard.value(forKey: UDKeys.id) else { return }
        guard let teacherId = value as? Int else { return }
        let strTeacherId = String(teacherId)

        guard schedule.stringId != strTeacherId else { /// if schedule already downloaded
            let response = ScheduleModels.Classes.Response(dayClasses: schedule.classes, dayInfo: request)
            presenter?.presentClasses(with: response)
            return
        }
        components.path = "/teacher_classes/" + strTeacherId
        guard let url = components.url else { return }
        
        let task = URLSession.shared.dataTask(with: url) { data, response, error in
            if let data = data, let classes = try? JSONDecoder().decode(ScheduleModels.Classes.ResponseItems.self, from: data) {
                DispatchQueue.main.async {
                    let response = ScheduleModels.Classes.Response(dayClasses: classes, dayInfo: request)
                    self.presenter?.presentClasses(with: response)
                    self.schedule.classes = classes
                    self.schedule.stringId = strTeacherId
                }
            }
        }
        task.resume()
    }
} // print(String(decoding: data!, as: UTF8.self))
